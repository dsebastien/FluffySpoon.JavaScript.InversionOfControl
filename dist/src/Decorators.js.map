{"version":3,"file":"Decorators.js","sourceRoot":"","sources":["../../src/Decorators.ts"],"names":[],"mappings":";;AAAA,4BAA0B;AAE1B,yCAAsG;AAEtG,SAAgB,qBAAqB,CAAC,iBAAsB,EAAE,sBAA2B;IACrF,IAAM,SAAS,GAAG,4BAAgB,CAAC,iBAAiB,CAAC,CAAC;IAEtD,IAAI,IAAI,GAAG,OAAO,CAAC,WAAW,CAAC,mBAAmB,EAAE,iBAAiB,CAAU,CAAC;IAEhF,0BAAc,CAAC,sBAAsB,EAAE,MAAM,EAAE,SAAS,CAAC,CAAC;IAC1D,0BAAc,CAAC,sBAAsB,EAAE,eAAe,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAEjF,IAAI,2BAA2B,GAAG,iDAAqC,CAAC,iBAAiB,CAAC,CAAC;IAE3F,IAAI,eAAe,GAAG,2BAA2B,CAAC,mBAAmB,EAAE,CAAC;IACxE,KAAyB,UAAe,EAAf,mCAAe,EAAf,6BAAe,EAAf,IAAe,EAAE;QAAtC,IAAI,aAAa,wBAAA;QACjB,IAAG,CAAC,IAAI,CAAC,aAAa,CAAC;YACnB,MAAM,IAAI,KAAK,CAAC,qEAAqE,GAAG,aAAa,GAAG,YAAY,GAAG,SAAS,GAAG,yBAAyB,GAAG,SAAS,GAAG,0CAA0C,CAAC,CAAC;QAE3N,2BAA2B,CAAC,sBAAsB,CAAC,aAAa,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;KAC1F;AACL,CAAC;AAjBD,sDAiBC;AAED,SAAgB,UAAU,CAAyC,WAAc;IAC7E,qBAAqB,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;IAChD,OAAO,WAAW,CAAC;AACvB,CAAC;AAHD,gCAGC;AAED,SAAgB,MAAM,CAAC,MAAW,EAAE,YAAoB,EAAE,cAAsB;IAC5E,IAAI,2BAA2B,GAAG,iDAAqC,CAAC,MAAM,CAAC,CAAC;IAChF,2BAA2B,CAAC,sBAAsB,CAAC,cAAc,CAAC,CAAC;AACvE,CAAC;AAHD,wBAGC","sourcesContent":["import \"reflect-metadata\";\r\n\r\nimport { defineMetadata, getOrCreateArgumentsMetadataForTarget, extractClassName } from \"./Utilities\";\r\n\r\nexport function addInjectableMetadata(sourceConstructor: any, destinationConstructor: any) {\r\n    const className = extractClassName(sourceConstructor);\r\n\r\n    let type = Reflect.getMetadata(\"design:paramtypes\", sourceConstructor) as any[];\r\n\r\n    defineMetadata(destinationConstructor, 'name', className);\r\n    defineMetadata(destinationConstructor, 'argumentCount', !type ? 0 : type.length);\r\n\r\n    let argumentInjectionDictionary = getOrCreateArgumentsMetadataForTarget(sourceConstructor);\r\n\r\n    let argumentIndexes = argumentInjectionDictionary.getParameterIndexes();\r\n    for(var argumentIndex of argumentIndexes) {\r\n        if(!type[argumentIndex])\r\n            throw new Error('Could not extract type information for constructor parameter index ' + argumentIndex + ' of class ' + className + '. Make sure that class ' + className + ' is defined below the class it is using.');\r\n\r\n        argumentInjectionDictionary.updateParameterAtIndex(argumentIndex, type[argumentIndex]);\r\n    }\r\n}\r\n\r\nexport function Injectable<T extends { new(...args: any[]): any }>(constructor: T) {\r\n    addInjectableMetadata(constructor, constructor);\r\n    return constructor;\r\n}\r\n\r\nexport function Inject(target: any, _propertyKey: string, parameterIndex: number) {\r\n    let argumentInjectionDictionary = getOrCreateArgumentsMetadataForTarget(target);\r\n    argumentInjectionDictionary.updateParameterAtIndex(parameterIndex);\r\n}"]}